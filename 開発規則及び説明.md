# 開発規則及び説明

- [プロジェクト構造](#プロジェクト構造)
- [業務規則](#業務規則)
- [命名規則](#命名規則)
- [クラス説明](#クラス説明)
- [補充](#補充)

>

###### 説明：バックエンドアプリケーションの開発において、原則的に本規則に従って開発する
######  本規則は site モジュールだけに適用する
###### （但し、正当な理由がある場合、その理由を本規約の[補充](#補充)部分に記述する）

>

## プロジェクト構造

com.pots  
│  
├── common  
│ ├── config      
│ ├── constant    
│ ├── model       
│ └── utils       
│  
├── site  
│ ├── controller  
│ ├── mapper      
│ ├── model       
│ └── service     
│  
└── admin           
│ ├── controller  
│ ├── mapper      
│ ├── model       
│ └── service

>

## 業務規則
1. プロジェクト全体、高凝集・低結合のルールを意識して開発する
2. パフォーマンスに著しく影響しない限り、保守維持を容易にするため、多少のパフォーマンスを犠牲にしても構わない
3. XXXServiceImplは別のserviceを使用することは可能、但し、直接別のmapperを使用しない([業務規則](#業務規則)の1を参照)  
   例：
   - GameServiceImpl で CharaService を使用するのは ✅  
   - GameServiceImpl で CharaMapper を使用するのは ❌
4. 全てのデータベースからデータを抽出する操作は、主テーブルに is_active 列がある限り、  
   必ず is_active = true を条件として指定する
5. coordinator層:各serviceで違うサービスのmapperを使う可能性があるため、役割が混雑になるため、
   coordinator層で統一管理し、循環依存を避けて単一責任の原則を維持できる

>

## 命名規則

1. 通常変数の命名規則はキャメルケースの形式を使用する
2. 変数の命名規則は基本的にキャメルケースの形式を使用する  
3. フロントとバックエンドのAPI通信において、両方の変数名は必ず一致にする  
   ***(複合型のVOクラスの場合、メンバー変数の命名はフロントエンドの命名に従う（バックエンドの命名スタイルを使用しない）)***  
   例：[GameDetailVO.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fmodel%2Fvo%2FGameDetailVO.java)
   ```java
   private GameVO gameData;
   private List<CharaForGameVO> charaInGameArr;
   ```
4. APIパラメータ値はcontrollerの@Param()と一致する  
   例：[GameController.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fcontroller%2FGameController.java)
   ```java
   public Result<GameDetailVO> sendGameDetail(@PathVariable Long gameId,HttpServletRequest request);
   ```
5. mapperの@Param( )値xmlファイルの#{ }と一致する
   例：  
   mapper->[GameMapper.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fmapper%2FGameMapper.java)  
   xml  ->[GameMapper.xml](src%2Fmain%2Fresources%2Fmapper%2FGameMapper.xml)
6. mapperにメソッドの命名は **"動作 + 目標 + 条件"**  
   *langCode条件は基本的に必要のため、命名に省略可*
    例：
   ```java
   GameVO findGameByGameId(@Param("langCode") String langCode,@Param("gameId") Long gameId);
   ```
7. controllerクラスの命名は **"使用範囲 + Controller"**  
   例：[GameController.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fcontroller%2FGameController.java)
8. controllerメソッドの命名は **"send + 結果対象"**
   例：  
    ```java
    public Result<List<GameVO>> sendAllGame(HttpServletRequest request);
    ```
9. serviceインタフェイスの命名は **"使用範囲 + Service"**  
   例：[GameService.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fservice%2FGameService.java)
10. serviceインタフェイスにメソッドの命名は **"get + 返り値のデータ型 + 条件"**  
    *langCode条件は基本的に必要のため、命名に省略可*  
     例：
    ```java
    GameDetailVO getGameDetailVO(String langCode,Long gameId);
    ```
11. serviceImplクラスの命名は **"実装したserviceインタフェイス名 + Impl"**  
    例：[GameServiceImpl.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fsite%2Fservice%2Fimpl%2FGameServiceImpl.java)
12. 列挙型(Enum)クラスの命名は：**"使用範囲 + Type"**（例：ResultType）  
    メンバー定数は基本的に英大文字とスネークケース（例：SUCCESS, FAILED,
    NO_ACCEPT_LANGUAGE）  
    例：[ResultType.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fmodel%2FResultType.java)
13. 定数クラスの命名は **"使用範囲 + Const"**
    例：[PropConst.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fconstant%2FPropConst.java)


>


## クラス説明

### [定数クラス](#定数クラス)

1. [PropConst](#PropConst)
2. [UrlConst](#UrlConst)

### [基礎クラス](#基礎クラス)

1. [EntityBase](#EntityBase)
2. [EntityBaseOrigin](#EntityBaseOrigin)
3. [Entity系](#Entity系)
4. [VO系](#VO系)
5. [DTO系](#DTO系)
6. [RO系](#RO系)
7. [ResultType](#ResultType)
8. [Result](#Result)

### [ユーティリティクラス](#ユーティリティクラス) 
**(ツールクラスのため、全部継承不可なfinalクラスである)**

1. [Inspector](#Inspector)
2. [LangCheckResult](#LangCheckResult)
3. [SnowflakeIdWorker](#SnowflakeIdWorker)
4. [DataConverter](#DataConverter)

---

### 定数クラス

#### PropConst

- ヘッダのkeyなど変更しない属性値をメンバー定数に格納されているクラス  
  [PropConst.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fconstant%2FPropConst.java)
    ```java
    public static final String      ACCEPT_LANGUAGE  = "Accept-Language";
    ```

#### UrlConst

- Urlの共用部分の定数を格納されているクラス  
  [UrlConst.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fconstant%2FUrlConst.java)
    ```java
    private static final String UPLOAD_FOLDER = "http://localhost:8087/uploads/";
    ```

---

### 基礎クラス

#### EntityBase

- [EntityBase.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fmodel%2FEntityBase.java)
- 抽象クラス、全テーブル通用の属性しか定義しない  
  ```java
  public abstract class BaseEntityOrigin {
  
      private Long          creatorId;    // not null
      private LocalDateTime createTime;   // not null default CURRENT_TIMESTAMP
      private Long          updaterId;    // default null
      private LocalDateTime updateTime;   // default null on update CURRENT_TIMESTAMP
  
  }
  ```
- 上記の通り、作成者のid と 更新者のid だけ管理者のidを入れる必要がある
- 作成日時と更新日時はデータベース自動入力
- **必須でない限り、各テーブルの上記データは変更不可**

#### EntityBaseOrigin

- [EntityBaseOrigin.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fmodel%2FEntityBaseOrigin.java)
- 上記抽象クラス [EntityBase](#EntityBase) から継承、主テーブル用の状態管理用カラムが追加されている
  ```java
  public abstract class BaseEntity extends BaseEntityOrigin {
    
      private Boolean isActive;     // not null default true
    
  }
  ```

#### Entity系

- 全てのエンティティは上記抽象クラス EntityBaseOrigin 又は EntityBase から継承する
- メンバー変数はテーブルの列名と一致にする (camelCase->snake_case)
- idは必ず[SnowflakeIdWorker](#SnowflakeIdWorker)を使用して生成する
- エンティティをレスポンスとして直接フロントに返すことを絶対しない

#### VO系

- フロントにレスポンスを返す時基本的にVOオブジェクトを使用する

#### DTO系

- 現時点 (2025.04.14) で作成する必要はない、今後管理システム実装する時に作成する可能性あり

#### RO系
- フロントからpostリクエストのデータを受け取るに使用する


#### ResultType

- [ResultType.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fmodel%2FResultType.java)
- 列挙型クラス、すべてのリクエストのステータスとメッセージを管理して、リクエスト応答の一貫性を確保し、メンテナンスを容易にします。  
- 基本的に com.pots.common.utils パッケージ 以外で直接使用しない
- 下記[Result](#Result)クラス静的メソッドResult.successやfailで内部で使用されるため、呼び出し元は意識せず統一的にレスポンスが作られる

#### Result
- [Result.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Fmodel%2FResult.java)
- レスポンスをフロントに返す時、一律に総称型Resultクラスの静的メソッドを使用する  
  **(総称型を通じて特定のデータ型を指定する)**
- メソッド全部静的であり、レスポンス成功と失敗のメソッドは各自のオーバーロードあり

---

### ユーティリティクラス

#### Inspector

- [Inspector.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Futils%2FInspector.java)
- 各種パラメータのチェックメソッドが格納されている
- メソッド名は XXXCheck にする
- 返り値のデータ型は com.pots.common.model の"XXXCheckResult"を使用する
- siteモジュールの各リクエストに対して、絶対InspectorクラスのlanguageCheckメソッドでチャックする

#### LangCheckResult

- [LangCheckResult.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Futils%2FLangCheckResult.java)
- 上記 [Inspector](#Inspector) のメソッドの返り値のとしてこのクラスを使用する
- レコードクラスである(説明URL：https://docs.oracle.com/javase/jp/15/language/records.html)
- 上記 [Inspector](#Inspector) の languageCheckメソッド の返り値として使うため、変更不可なレコードクラスにする

#### SnowflakeIdWorker

- [SnowflakeIdWorker.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Futils%2FSnowflakeIdWorker.java)
- データベース各テーブルのidカラムの値は全部このクラスを使用して生成する
- プロパティファイル([application.yml](src%2Fmain%2Fresources%2Fapplication.yml))から自動的にメンバー変数の値を読み込む

#### DataConverter

- [DataConverter.java](src%2Fmain%2Fjava%2Fcom%2Fpots%2Fcommon%2Futils%2FDataConverter.java)
- データマッピング用、現時点 (2025.04.14) では、使用箇所がない

>

### 補充
###### ここでは、開発規則に関して特別な理由があり、通常の規則を逸脱する場合の具体的な説明を記述します。これらのケースは稀であり、必ず明確な理由を説明する必要があります。

---

1. 特殊なケースでの命名規則変更  
  例: 外部APIから取得したデータを処理するクラスの命名を外部APIの仕様に合わせる場合。

2. データベース設計における例外  
  例: 大量のログデータを扱う場合、正規化された設計を犠牲にしてパフォーマンス向上を図ることがある。
   
3. 例外的なフロントエンドと通信する際の命名規則  
  例: フロントエンドがリスポンスを受け取る際に使うデータ型、メンバー変数の名称が特定の命名規則を遵守している場合、その命名規則にバックエンドも合わせる。
   
4. パフォーマンスのためのコードの最適化  
  例: 高速なデータ処理が求められる場合、forループの最適化や並列処理を取り入れることがある。

5. 外部ライブラリ使用の際の規約変更  
  例: セキュリティライブラリによるカスタムエラーハンドリングや、認証機能の特別な命名規則に従う必要が生じた場合。

